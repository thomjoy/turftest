<html>
<head>
  <title>Turf Test</title>
  <script src="//api.tiles.mapbox.com/mapbox.js/v2.1.5/mapbox.js"></script>
  <script src="//api.tiles.mapbox.com/mapbox.js/plugins/turf/v1.3.0/turf.min.js"></script>
  <script src="//code.jquery.com/jquery-2.1.3.js"></script>

  <script src="//localhost:3000/q.js"></script>
  <script>Q.longStackSupport = true;</script>

  <link href="https://api.tiles.mapbox.com/mapbox.js/v2.1.5/mapbox.css" rel="stylesheet" />
  <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600,300' rel='stylesheet' type='text/css'>
  <link href="style.css" rel="stylesheet" />

</head>
<body>
  <div class="left">
    <h1 id="header">NSW Buses Explorer</h1>
    <div id="location-info">
      <div id="stops-nearby"></div>
    </div>
    <div id="stop-container">
      <h2 id="stop-name"></h2>
      <p id="stop-distance"></p>
    </div>

    <div id="route-container">
      <div id="arriving-soon-container">
        <h2 class="header">Arriving Soon</h2>
        <ul id="arriving-soon"></ul>
      </div>

      <div id="all-routes-container">
        <h2 class="header" id="">All routes from this stop</h2>
        <div id="all-routes">
          <select></select>
        </div>
      </div>
    </div>

    <div id="shape-container">
      <div id="shape-info">
        <div class="header" id="shape-meta"></div>
      </div>
    </div>
  </div>
  <div class="right">
    <div id="map"></div>
  </div>
  <script>
    var liveTrafficUrl = 'http://livetraffic.rta.nsw.gov.au/traffic/hazards/incident.json';

    L.mapbox.accessToken = 'pk.eyJ1IjoidGhvbWpveTE5ODQiLCJhIjoiTGx2V3ZUVSJ9.pZlOrVUXu_aC1i0nTvpIpA';

    // constants
    var WALKING_DISTANCE = 0.25;

    // map layers
    var stopsGeoJson;
    var shapeLayer;
    var startEndRouteLayer;

    // global stops layer, needs to be cleared on drag
    var nearestStopsLayer;

    var map = L.mapbox.map('map', 'thomjoy1984.igjcb5m0');
    var baseCoords = new L.latLng(-33.865,151.209);
    map.setView(baseCoords, 16);
    L.control.scale().addTo(map);

    var icon = L.mapbox.marker.icon({
      "marker-color": "#8E8E8E",
      "title": "where are the stations?",
      "marker-symbol": "pitch",
      "marker-size": "small"
    });

    // our draggable icon that will be in the centre of a 0.5 mile radius
    var positionMarker = L.marker(baseCoords, {
      icon: icon,
      draggable: true,
      zIndexOffset:999
    }).addTo(map);

    // some utility functions
    function pointRadius(pt, radius, units, resolution) {
      var ring = [],
          resMultiple = 360/resolution;

      for(var i  = 0; i < resolution; i++) {
        var spoke = turf.destination(pt, radius, i*resMultiple, units);
        ring.push(spoke.geometry.coordinates);
      }

      if((ring[0][0] !== ring[ring.length-1][0]) && (ring[0][1] != ring[ring.length-1][1])) {
        ring.push([ring[0][0], ring[0][1]]);
      }

      return turf.polygon([ring])
    }

    // the center of the radial, initially.
    var point = turf.point(151.209, -33.865);

    // radius
    var radiusLayer = L.mapbox.featureLayer().addTo(map);
    var radial = pointRadius(point, .25, 'kilometers', 120);
    var radialStyle = {
      "fill": "#6baed6",
      "fill-opacity": 0.1,
      "stroke": "#3182bd",
      "stroke-width": 2,
      "stroke-opacity": 0.5
    };

    radial.properties = radialStyle;
    radiusLayer.setGeoJSON(radial);


    function xhr(options) {
      var deferred = Q.defer(),
          req = new XMLHttpRequest();

      req.open(options.method || 'GET', options.url, true);

      // Set request headers if provided.
      Object.keys(options.headers || {}).forEach(function (key) {
        req.setRequestHeader(key, options.headers[key]);
      });

      req.onreadystatechange = function(e) {
        if(req.readyState !== 4) {
          return;
        }

        if([200,304].indexOf(req.status) === -1) {
          deferred.reject(new Error('Server responded with a status of ' + req.status));
        }
        else {
          deferred.resolve(e.target.response);
        }
      };

      req.send(options.data || void 0);

      return deferred.promise;
    }

    function addShapeLayer(data) {
      var myStyle = {
        "color": "#fc8d59",
        "weight": 3,
        "opacity": 1
      };

      // clear previous
      if( shapeLayer )
        map.removeLayer(shapeLayer);
      if( startEndRouteLayer )
        map.removeLayer(startEndRouteLayer);

      shapeLayer = L.geoJson(data, {
        onEachFeature: function(feature, layer) {
          layer.setStyle(myStyle);
          layer.on({
            add: function() {
              //map.fitBounds(data.bbox[0], data.bbox[1]);
              map.fitBounds(shapeLayer.getBounds());
            },
            click: function(evt) {
              console.log('Clicked on shape');
              console.log(evt);
            }
          });
        }
      });

      function generateMarkerGeoJson(coords) {
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [coords[0], coords[1]]
          },
          properties: {
            "marker-size": "small",
            "marker-color": "2775DB",
            "marker-symbol": "bus"
          }
        }
      }

      var c = data.geometry.coordinates;
      var endPoints = [generateMarkerGeoJson(c[0]), generateMarkerGeoJson(c[c.length-1])];
      endPoints[0].properties["title"] = "Start";
      endPoints[0].properties["marker-color"] = "31a354";
      endPoints[1].properties["title"] = "End";
      endPoints[1].properties["marker-color"] = "a50f15";

      // generate this on the server?
      startEndRouteLayer = L.mapbox.featureLayer()
                            .setGeoJSON({ type: "FeatureCollection", features: endPoints });

      startEndRouteLayer.eachLayer(function(marker) {
        marker.bindPopup(marker.feature.properties.title);
        marker.openPopup();
      });

      startEndRouteLayer.addTo(map);
      shapeLayer.addTo(map);
    }

    // main func
    function calcStopsInRadius() {
      // clear previous
      if( nearestStopsLayer )
        map.removeLayer(nearestStopsLayer);

      var withinRadius = turf.featurecollection(stopsGeoJson.features.filter(function(stop){
        if (turf.distance(stop, point, 'kilometers') <= WALKING_DISTANCE) return true;
      }));

      if( withinRadius.features.length > 0 ) {
        $('#stops-nearby')
          .html('<span id="num-stops">' + withinRadius.features.length + ' </span>bus stops within <span id="walking-distance">' + WALKING_DISTANCE + 'km</span>');

        withinRadius.features.forEach(function(feature){
            var distance = parseFloat(turf.distance(point, feature, 'kilometers'));
            var popupContent = '<strong class="stop-name">' + feature.properties.stop_name + '</strong> <span class="stop-id">(' + feature.properties.stop_id + ')</span>' +
                        '<div id="services-next"></div>' +
                        '<div id="service-info"></div>';

            feature.properties["marker-color"] = "2775DB";
            feature.properties["title"] = popupContent;
            feature.properties["marker-size"] = "small";
            feature.properties["marker-symbol"] = "bus";
        });

        var nearest = turf.nearest(point, withinRadius);
        var nearestdist = parseFloat(turf.distance(point, nearest, 'kilometers'));

        nearest.properties["marker-color"] = "ffffff";
        nearest.properties["title"] = '<strong class="stop-name">' + nearest.properties.stop_name +'</strong> <span class="stop-id">(' + nearest.properties.stop_id + ')</span>' +
                        '<div id="services-next"></div>' +
                        '<div id="service-info"></div>';
        nearest.properties["marker-size"] = "small";
        nearest.properties["marker-symbol"] = "bus";

        nearestStopsLayer = L.mapbox.featureLayer()
                            .setGeoJSON(turf.featurecollection([withinRadius, nearest]));

        nearestStopsLayer.eachLayer(function(marker) {
          var feature = marker.feature;
          var stop_id = feature.properties.stop_id;
          var stopName = feature.properties.stop_name;

          marker.on('click', function(e) {
            marker.bindPopup(feature.properties.title, {minWidth: 240, maxWidth: 300, closeButton: true});
            marker.openPopup();

            marker.feature.properties['marker-color'] = '3cb371'; //mediumseagreen
            var _thismarker = marker;

            nearestStopsLayer.eachLayer(function(_marker) {
              if(_marker._leaflet_id !== _thismarker._leaflet_id)
                marker.feature.properties['opacity'] = 0.4;
            });

            var featureMarker = {
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates: [positionMarker.getLatLng().lng, positionMarker.getLatLng().lat]
              }
            };

            var distance = turf.distance(featureMarker, marker.feature, 'kilometers');
            $('#stop-distance').html((distance * 1000).toPrecision(3) + 'm from your position');

            var prm = xhr({url: 'http://127.0.0.1:3001/stops/' + stop_id}).done(function(data) {
              var data = JSON.parse(data);
              //var arrivingSoonList = $('#arriving-soon').empty();
              var allRoutesSelect = $('#all-routes select');
              var optionEls = [];

              $('#stop-name').html(stopName);

              // add Routes to the sidebar
              // make route listing a <select>
              // add recently arriving services as per the current format
              data.forEach(function(d) {
                //var listEl = $('<li class="fetch-shape" data-shapeid="' + d.shape_id + '"></li>');
                var optionEl = $('<option class="fetch-shape" value="' + d.shape_id + '">' + d.route_short_name + ' - ' + d.route_long_name + '</option>');
                optionEls.push(optionEl);
              });

              // add the all routes select to the div
              $('#all-routes-container h2').show();
              $('#all-routes').html(allRoutesSelect.html(optionEls));

              $('#all-routes select').on('change', function(evt) {
                var optionSelected = $('option:selected', this);
                var shapeId = this.value;

                getShapeData(shapeId);
                  getStopsForShape(shapeId, function(stopsData) {
                    var elData = "";
                    var elData = '<div class="header" id="shape-meta">' + stopsData.length + ' stops in xx minutes (est)</div>';

                    stopsData.forEach(function(s) {
                      var highlightRow = $('#stop-name').text() === s.stop_name ? ' highlight' : '';
                      elData += '<div class="stop-on-shape' + highlightRow + '" data-stopId="' + s.stop_id + '"><strong>' + s.departure_time.substring(0, s.departure_time.length - 6) + '</strong> ' + s.stop_name + '</div>';
                    });
                    $('#shape-info h2').show();
                    $('#shape-info').html(elData).show();
                  });
              });

              // add Upcoming buses to the Popup
              getServicesInMinutes(stop_id, 5, function(data) {
                var arrivingSoon = $('#arriving-soon');
                var arrivingSoonItems = [];

                data.forEach(function(d) {
                  var arr = (d.departure_time.split(':'));
                  var depTime = arr[0] + ':' + arr[1];
                  var li = '<li class="service"><strong class="bus-number">' + d.route_id.split('_')[1] + '</strong>' +
                    ' arr in ' + d.departure_time_mins + 'm (' + depTime + ')</li>';
                  arrivingSoonItems.push(li);
                });

                $('#arriving-soon-container h2').show();
                arrivingSoon.html(arrivingSoonItems);

              });
            });
          });
        });
        nearestStopsLayer.addTo(map);
      }
    }

    // get the stops.json file from the server
    function getStopsData() {
      var prm = xhr({url:'http://127.0.0.1:3000/gtfs/stops.json'});
      prm.done(function(geojson) {
          stopsGeoJson = JSON.parse(geojson);
          calcStopsInRadius();
      });
    };

    function getShapeData(shape_id) {
      var prm = xhr({url:'http://127.0.0.1:3001/shapes/' + shape_id});
      prm.done(function(geojson) {
        var geojson = JSON.parse(geojson);
        addShapeLayer(geojson);
      });
    }

    function getServicesInMinutes(stopId, minutes, cb) {
      var prm = xhr({url:'http://127.0.0.1:3001/stops/' + stopId + '/in/' + minutes});
      prm.done(function(services) {
        cb(JSON.parse(services));
      });
    }

    function getStopsForShape(shapeId, cb) {
      var prm = xhr({url:'http://127.0.0.1:3001/stops/along/' + shapeId});
      prm.done(function(stops) {
        cb(JSON.parse(stops));
      });
    }

    // event handlers
    positionMarker.on('drag', function(evt) {
      var lat = this.getLatLng()['lat'];
      var lon = this.getLatLng()['lng'];

      // clear the sidebar
      $('#route-info').empty();

      // global
      point = turf.point(lon, lat);
      var radial = pointRadius(point, WALKING_DISTANCE, 'kilometers', 120);
      radial.properties = radialStyle;
      radiusLayer.setGeoJSON(radial);

      calcStopsInRadius();
    });

    // go
    getStopsData();
  </script>
</body>
</html>